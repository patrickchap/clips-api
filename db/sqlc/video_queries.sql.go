// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: video_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVideo = `-- name: CreateVideo :one
INSERT INTO videos (
  title,
  description,
  file_url,
  thumbnail_url,
  user_id
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, title, description, file_url, thumbnail_url, user_id, created_at
`

type CreateVideoParams struct {
	Title        string `json:"title"`
	Description  string `json:"description"`
	FileUrl      string `json:"file_url"`
	ThumbnailUrl string `json:"thumbnail_url"`
	UserID       string `json:"user_id"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRow(ctx, createVideo,
		arg.Title,
		arg.Description,
		arg.FileUrl,
		arg.ThumbnailUrl,
		arg.UserID,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FileUrl,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVideo = `-- name: DeleteVideo :exec
DELETE FROM videos 
WHERE id = $1
`

func (q *Queries) DeleteVideo(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteVideo, id)
	return err
}

const getUserVideoWithLikes = `-- name: GetUserVideoWithLikes :many
SELECT
    v.id, v.title, v.description, v.file_url, v.thumbnail_url, v.user_id, v.created_at,
    COUNT(l.id) AS like_count
FROM
    videos v
LEFT JOIN
    likes l ON v.id = l.video_id
WHERE
    v.user_id = $3::text
GROUP BY
    v.id
ORDER BY 
    v.created_at desc
LIMIT $1
OFFSET $2
`

type GetUserVideoWithLikesParams struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	UserID string `json:"user_id"`
}

type GetUserVideoWithLikesRow struct {
	ID           int64            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	FileUrl      string           `json:"file_url"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       string           `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	LikeCount    int64            `json:"like_count"`
}

func (q *Queries) GetUserVideoWithLikes(ctx context.Context, arg GetUserVideoWithLikesParams) ([]GetUserVideoWithLikesRow, error) {
	rows, err := q.db.Query(ctx, getUserVideoWithLikes, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserVideoWithLikesRow{}
	for rows.Next() {
		var i GetUserVideoWithLikesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FileUrl,
			&i.ThumbnailUrl,
			&i.UserID,
			&i.CreatedAt,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVideo = `-- name: GetVideo :one
SELECT id, title, description, file_url, thumbnail_url, user_id, created_at FROM videos 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVideo(ctx context.Context, id int64) (Video, error) {
	row := q.db.QueryRow(ctx, getVideo, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FileUrl,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getVideoWithLikes = `-- name: GetVideoWithLikes :one
SELECT
    v.id, v.title, v.description, v.file_url, v.thumbnail_url, v.user_id, v.created_at,
    COUNT(l.id) AS like_count
FROM
    videos v
LEFT JOIN
    likes l ON v.id = l.video_id
WHERE
    v.id = $1
GROUP BY
    v.id
`

type GetVideoWithLikesRow struct {
	ID           int64            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	FileUrl      string           `json:"file_url"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       string           `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	LikeCount    int64            `json:"like_count"`
}

func (q *Queries) GetVideoWithLikes(ctx context.Context, id int64) (GetVideoWithLikesRow, error) {
	row := q.db.QueryRow(ctx, getVideoWithLikes, id)
	var i GetVideoWithLikesRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FileUrl,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.LikeCount,
	)
	return i, err
}

const getVideoWithLikesWithSearch = `-- name: GetVideoWithLikesWithSearch :one
SELECT
    v.id, v.title, v.description, v.file_url, v.thumbnail_url, v.user_id, v.created_at,
    COUNT(l.id) AS like_count
FROM
    videos v
LEFT JOIN
    likes l ON v.id = l.video_id
WHERE
    v.id = $1
GROUP BY
    v.id
`

type GetVideoWithLikesWithSearchRow struct {
	ID           int64            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	FileUrl      string           `json:"file_url"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       string           `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	LikeCount    int64            `json:"like_count"`
}

func (q *Queries) GetVideoWithLikesWithSearch(ctx context.Context, id int64) (GetVideoWithLikesWithSearchRow, error) {
	row := q.db.QueryRow(ctx, getVideoWithLikesWithSearch, id)
	var i GetVideoWithLikesWithSearchRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.FileUrl,
		&i.ThumbnailUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.LikeCount,
	)
	return i, err
}

const listVideos = `-- name: ListVideos :many
SELECT id, title, description, file_url, thumbnail_url, user_id, created_at FROM videos 
ORDER BY id 
LIMIT $1
OFFSET $2
`

type ListVideosParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListVideos(ctx context.Context, arg ListVideosParams) ([]Video, error) {
	rows, err := q.db.Query(ctx, listVideos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Video{}
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FileUrl,
			&i.ThumbnailUrl,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosWithLikesAndSearch = `-- name: ListVideosWithLikesAndSearch :many
SELECT
    v.id, v.title, v.description, v.file_url, v.thumbnail_url, v.user_id, v.created_at,
    COUNT(l.id) AS like_count
FROM
    videos v
LEFT JOIN
    likes l ON v.id = l.video_id
WHERE
    v.title ILIKE $3::text
OR
    v.description ILIKE $3::text
GROUP BY
    v.id
ORDER BY 
	v.created_at desc

LIMIT $1
OFFSET $2
`

type ListVideosWithLikesAndSearchParams struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Search string `json:"search"`
}

type ListVideosWithLikesAndSearchRow struct {
	ID           int64            `json:"id"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	FileUrl      string           `json:"file_url"`
	ThumbnailUrl string           `json:"thumbnail_url"`
	UserID       string           `json:"user_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	LikeCount    int64            `json:"like_count"`
}

func (q *Queries) ListVideosWithLikesAndSearch(ctx context.Context, arg ListVideosWithLikesAndSearchParams) ([]ListVideosWithLikesAndSearchRow, error) {
	rows, err := q.db.Query(ctx, listVideosWithLikesAndSearch, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVideosWithLikesAndSearchRow{}
	for rows.Next() {
		var i ListVideosWithLikesAndSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FileUrl,
			&i.ThumbnailUrl,
			&i.UserID,
			&i.CreatedAt,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
